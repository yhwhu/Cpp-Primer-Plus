# 第9章 内存模型和名称空间



## 9.1 单独编译

- 组织程序的策略：

  - 头文件：函数原型，符号常量，结构声明，类声明，模块声明，内联函数。
  - 源代码文件：函数定义。
  - 源代码文件：函数调用。

- include：

  ```c++
  #include <coordin.h>;  // 编译器首先在存储标准头文件的文件系统中查找。
  #include "coordin.h";  //           当前目录或源代码目录
  ```

- 在同一个文件中只能将同一个头文件包含一次，使用 #ifndef 避免，如果在同一个文件中遇到其他包含 coordin.h 的代码，编译器将知道 COORDIN_H_ 已经被定义了，从而跳到 #endif 后面的一行上。

  - ```c++
    #ifndef COORDIN_H_
    ...
    #endif
    ```

  

## 9.2 存储持续性、作用域和链接性

- 存储数据的方案：

  - 自动存储持续性：执行到代码块时被创建，执行完时释放。
  - 静态存储持续性：整个运行过程中都存在，固定内存块预先分配好。
  - 线程存储持续性：生命周期与线程一样长，用于并行处理的不同线程。
  - 动态存储持续性：new 分配的内存一直存在，直到 delete。（自由存储，堆）

- 自动变量初始化：

  ```c++
  int x = 5;
  int y;
  ```

- 使用栈来管理自动变量，一个指针指向栈底，一个指针指向堆顶——下一个可用内存单元。

- 静态变量初始化：

  - 外部链接性（全局变量）：能在文件之间使用。

    ```c++
    // 在函数外部定义
    double x = 200;
    
    // 在其他文件声明，不能重新定义！
    extern double x;
    ```

  - 内部链接性：只能在该文件内使用。

  - ```c++
    // 在函数外部定义
    static double x = 200;
    ```

  - 无链接性：只能在代码块中使用，但是不同于自动变量，会一直存在，可用于计数情景。

  - ```c++
    // 在代码块中定义
    static double x = 200;
    ```

- mutable 声明的作用：即使结构或类变量为 const，某个成员也可以被修改。

- const 限定符会将默认存储类型变量的链接性改为内部的。

- 函数也有链接性，不允许一个函数中定义另一个函数，所以函数的存储持续性都是静态的。默认是外部链接，可以使用 static 设置为内部的，必须同时在原型和函数定义中使用。

- 动态存储：创建指针指向未命名的内存。

  ```c++
  int * pt = new int {3};
  int * pt = new int [40];
  ```



## 9.3 名称空间

- 通过定义一个新的声明区域来创建命名的名称空间，目的之一是一个名称空间的名称不会与另外一个名称空间的相同名称发生冲突。

- 名称空间声明的名称的链接性默认为外部的，除非引用了常量。
- 使用作用域解析符限定名称： Jack::Hill。

- using 声明：

  ```c++
  using std::cout;
  ```

- using 编译指令：

  ```c++
  using namespace std;
  ```

- using 编译指令更容易出错，对于相同的名称，局部版本会隐藏名称空间版本；同种情况下，using 声明会报错提醒。