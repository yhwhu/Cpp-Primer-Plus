# 第8章 函数探幽

## 内联函数

```c++
inline double square(double x){return x*x;}
```

- 可执行程序——由一组机器语言指令组成，运行程序时，操作系统将这些指令载入到计算机内存中，每条指令都有特定的内存地址。
- 函数调用：记录函数调用处的地址——函数参数复制到堆栈中——跳到函数起点标记的内存单元——执行函数——（也许讲返回值放到寄存器中 ）——跳回到地址被保存到指令处。
- 内联函数：编译器将使用相应的函数代码替换函数调用，所以运行速度稍快，但是需要更多的内存。（如果调用一个函数10次，则程序会包含10个副本）
- 常用于代码只有一行的函数。

## 引用变量
- 引用的好处：
  - 可以修改调用函数中的数据对象。
  - 通过传递引用而不是整个数据对象，可以**提高**程序的**运行速度**。
- 引用必须在声明的时候初始化，类似于 const 指针，一旦与某个变量关联起来，就将一直绑定它。
- 引用作为函数参数时，被初始化为实际参数。
- 尽可能使用 const ：
  - 可以避免无意修改数据的错误。
  - 可以同时处理 const 实参和 非 const 实参，否则只能接受非 const 数据。
  - 使函数正确生成并使用临时变量。（仅当参数为 const 引用时，下面两种情况时，C++ 生成临时匿名变量，引用指向它）
    - 实参的类型正确，但不是左值（可以被引用的数据对象）
    - 实参的类型不正确，但可以转换为正确的类型。（实参 int， 形参  double ）
- return 的机制：值被复制到一个临时变量，调用程序将使用这个值。（通常是复制给一个变量）
- 赋值语句中，左边必修是可以修改的左值，即可修改的内存块。
- 返回类型是 const &，表示返回值不能被修改。

## 函数重载

```c++
void func1(double x);  
void func2(int x);
```

- 函数完成相同的工作，但使用不同的参数列表。
- 没有匹配的原型时，编译器会尝试类型转换。
- 编译器检查特征标时，将类型引用和类型本身视为同一个特征标。

## 函数模版

```c++
// 函数原型和函数定义都需要第一行
template <typename AnyType> // or template<class AnyType>
void Swap(AnyType &a, AnyType &b){...}
```

- 函数模块不能缩短可执行程序，就像手工定义这些函数一样。

- 模块函数也可以重载。

- 显式具体化

  - ```c++
    template<> void Swap<job>(job &, job &);
    ```

  - 适用于针对某个特别的类型，函数内部的处理方式不同于模块函数。（理由如下）

  - 编译器选择原型时，非模块版本 优先于 显示具体化 优先于 模块生成的版本。

- 显式实例化

  - ```c++
    Swap<int>(a, b)
    ```

- 隐式实例化

  - ```c++
    Swap(a, b)
    ```

- 通常，有两个函数完全匹配是一种错误，二义性错误。两种特例：

  - 常规函数优先于模块函数。

  - 指向非 const 数据的指针和引用优先与非 const 指针和引用参数匹配。

  - ```c++
    blob ink;
    const blob ink2
    void recycle(blot &);        // func1        
    void recycle(const blot &);  // func2
    
    recycle(ink);  // func1 优先匹配
    recycle(ink2); // func2 优先匹配
    ```

- 完成匹配允许的无关紧要转换

  | 从实参   | 到形参     |
  | -------- | ---------- |
  | Type     | Type &     |
  | Type &   | Type       |
  | Type [ ] | * Type     |
  | Type     | const Type |
  | Type *   | const Type |

  